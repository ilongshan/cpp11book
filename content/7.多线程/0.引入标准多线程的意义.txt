在 C++11 多线程标准中, 除开能看得到用得着的线程库 (`std::thread` 等) 和多线程工具集 (`std::atomic`, `std::mutex` 等), 底层由编译器做出的一些改动也相当多, 值得注意.

在并发程序设计领域, 多线程之于多进程模型的一个优势在于不同线程直接可以直接通过内存访问来方便地共享数据. 而在 C++11 的线程模型中, 最重要的一点也当属为多个线程提供共享地址空间访问机制的内存位置模型.

在现有的 C++ 标准中, 描述对象所在的位置并不是直接用 "内存" 而是使用 "地址空间" 这一术语, 因为 C++ 这门语言是对程序设计的一种抽象. 语言在抽象的过程中不涉及到任何具体编译器, 操作系统, 硬件, 寄存器^[[虽然有 `register` 关键字, 但时至今日很少有人会使用它, 并且它在 C++11 中被列为淘汰的关键字]]或多级缓存, 只有地址空间的概念.

C++11 标准诞生之前并没有对应于多线程并发的地址空间模型, 任何多线程程序设计都算是 "野路子", 编译器对多个可能同时访问一个对象所在地址空间的线程概念一无所知, 也不会描述任何在这种情况下会产生的后果, 甚至根本不提两个线程同时读写一个对象是不是未定义行为. 在 C++11 中这些内容才被引入, 并提出**内存模型** (memory model) 来统一理想中的多线程模型与实际中的硬件体系结构.

内存模型与地址空间不同的地方在于, 内存模型会一定程度上考虑如何在具体的硬件架构上给出独立的地址空间的定义. 这种 "独立" 到什么程度呢? 不妨来考虑一下执行以下代码

```
struct Cell {
    char x;
    char y;
};

Cell c = { '0', '0' };

void thread_a()
{
    c.x = 'x';
}

void thread_b()
{
    c.y = 'y';
}

int main()
{
    // 假设函数 thread_start 用来启动线程
    thread_t a = thread_start(thread_a);
    thread_t b = thread_start(thread_b);
    // 假设函数 thread_join 用来等待线程结束
    thread_join(a);
    thread_join(b);
    // 两个线程都结束后, 输出 Cell 对象的各个值
    std::cout << c.x << ", " << c.y << std::endl;
    return 0;
}
```

按照常理来说, 预期的输出应当是 "x, y", 因为两个线程都分别修改了一个成员的值, 并且都结束了. 但若没有独立内存模型的话, 结果仍然可能是 "0, y" 或 "x, 0". 换言之, 即使不同线程访问的是不同的地址空间, 仍然有可能相互影响. 然而这是为什么呢?

对于 C++ 来说, `c` 的 `x` 和 `y` 两个成员确实处在不同的地址空间上, 但对于硬件来说, 它们可能在同一个内存区块. 一个内存区块通常是该体系结构上的一个字长的内存区, 可能存在某些体系结构的指令为了效率只能整个字长读写内存, 而缺乏单个字节访问内存的能力, 对于如以上 `thread_a` 里为一个 `char` 赋值的代码, 实际会产生 3 条指令

* 读取 `c.x` 所在的一个字长大小的内存区 (这时会连同 `c.y` 一起读入)
* 修改 `c.x` 对应的部分
* 写回到 `c.x` 所在的一个字长大小的内存区 (这时会连同 `c.y` 一起写回)

在多线程环境下, 非原子性的这三条指令当然有可能使得 `thread_a` 中写回 `c.x` 时错误地覆盖了另一线程写入的 `c.y` 的值. 反之在 `thread_b` 函数中亦然. 于是就出现了与期望不符的结果.^[[现实中, 如常见的 x86 体系结构可以保证总线将单个字节写回内存中, 因此并不会产生此现象.]]

因此为了避免上述情况发生, C++11 内存模型提出了一条核心保障: 当不同线程同时访问独立的**内存位置** (memory location) 时不会互相影响. 在前面的章节中提到过, C++ 为了保证不同的对象一定有不同的内存位置, 还设置了对空类型求 `sizeof` 会大于零这一与 C 不同的地方. 因此这一条保障也可以这么说, 当不同线程同时访问两个不同的对象时一定不会互相影响, 自然就包括了上面这种, 多个不同的变量挤占同一个硬件单元的情况.

绝大部分的 C++ 内建类型都有独立的内存位置, 多个线程即使访问同一个对象, 只要最终读写的成员是不同的, 就不会相互影响, 就像上例中同时写入 `c.x` 和 `c.y` 在 C++11 中不会出现数据竞争一样. 但位域 (bits field) 成员一般不具备独立的内存位置. 在 C++11 中规定, 长度非零的连续位域都可以具有相同的内存位置, 而长度为零的位域则用于分隔出不同的内存位置. 如

```
struct X {
    bool a;         // 内存位置 #0
    bool b;         // 内存位置 #1 : 连续 bool 也有单独的内存位置

    int b : 3;      // 内存位置 #2
    int c : 5;      // 内存位置 #2 : 与上面的 b 的位域连续, 处于统一内存位置

    int   : 0;      // 没有内存位置, 分隔上下两段位域的内存位置

    int d : 3;      // 内存位置 #3

    struct Nested {
        int e : 5;  // 内存位置 #4 : 单独 struct 定义, 不计作与 d 连续
    } f;
};
```

若一定要以位域方式节省内存, 并将对象交给多个线程并发访问, 则一定要加上同步, 否则就会导致未定义行为.
