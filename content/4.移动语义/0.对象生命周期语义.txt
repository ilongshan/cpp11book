= 由历史原因造成的 C++ 基本特性

C++ 最早被作为一门 C with classes 语言被发明出来. 不得不说这一第一印象也成为了对 C++ 最为广泛接受的刻板的印象. 然而在超过 30 年的发展之后, C++ 这门语言有着繁多的语言特性, 是 C 语言无法企及的, 而兼容 C 语言, 也只是 C++ 众多语言特性中的一个部分.

在兼容 C 语言这个部分, C++ 可以利用几乎所有 C 语言的 API, 包括一些操作系统 API. 在其他高级语言中, 调用 C API 可能需要编译封装, 或打包成库, 或以虚拟机接口的形式才能供用户所使用, 而 C++ 代码中却可以几乎没有任何代价地直接调用, 对于开发者而言显然是重大利好. 然而这样做有一些也有一些不妥之处, 最终导致了 C++ 复制构造的产生.

为了实现与 C API 的兼容, C++ 必须使用与 C 语言一致的栈式空间布局模型, 即栈式对象模型. 这一点与其他许多高级语言不一样. 将对象分配在栈空间内的好处是对其成员的使用皆可以编译为从栈基指针偏移寻址, 执行效率会非常高. 比如以下定义

```
struct Person {
    char name[16];
    int age;
};

int main()
{
    Person p; // 如果认为函数栈空间内定义的第一个对象的地址就是栈基址
    p.name;   // 那么引用 name 属性地址就相当于引用栈基指针
    p.age;    // 引用 age 属性相当于从栈基指针偏移 16 字节
              // 这些偏移量都可以静态给出, 因此执行效率会很高.

    // ...
}
```

当然, 优点往往会伴有缺点, 对于栈式对象模型也不例外: 其不足之处就是光凭栈内静态空间难以处理动态长度的数据, 譬如, 若须将 `Person` 的 `name` 属性设定为可动态扩展长度的字符串, 则这一段数据所需的地址空间就需要从堆上分配, 而在 C 语言中很麻烦的是, 用户还需要在使用完毕后手动归还这些堆空间.

但若是编写 C++ 程序, 则有更好的方案. 作为个例, 这里使用标准模板库中的 `std::string` 定义 `Person` 的 `name` 属性就能很容易地处理变长字符串. 之所以 `string` 具有这样的能力, 正是其内部管理了一份在堆空间中的动态资源所致. 当空间不够时, `string` 对象可以扩展其持有的空间. 然而, 与 C 中需要用户手动管理资源不同, `string` 将资源归还的行为进行了封装, 对用户而言是透明的, 比如, 在栈区定义一个 `Person` 对象, 会让函数返回后自动执行一些额外的操作

```
struct Person {
    std::string name;
    int age;
};

int main()
{
    Person p;
    std::cin >> p.name;
    // ...
    return 0;
    // 函数结束, 清理在栈上的对象 p:
    //     p.name 持有的资源被自动释放
    //     p.age 是个整数, 不用清理
}
```

这个规则当然不仅仅只被 `string` 所用, 更一般地, 在 C++ 中用于自动处理资源释放语言特性被称之为 "资源获取时初始化" (Resource Acquisition Is Initialization, 缩写为 RAII). 光看这个名字, 并不能很好地在字面上解释其背后的语言特性, 若要完整地说, 之后还应包含半句 "对象析构时将资源释放". 换言之, 在 C++ 中, 对于那些持有资源 (堆空间, 文件句柄等) 的对象, 编译器生成的代码将保证这些**对象所持有的资源的有效期与该对象的生命期严格一致**, 并且在对象生命周期结束时使用指定的方法自动归还这些资源.

具体的做法是用户按照以下规则编写代码

* 在对象的构造函数或生命周期过程中获取资源
* 在对象的析构函数中释放资源

然后编译器保证生成的应用程序有以下运行时行为

* 对象生命周期结束后其析构函数一定被调用

在这样的保障下, 对象所控制的资源的自动释放机制得以实现. 这是 C++ 之于 C 语言的本质不同, 甚至是 C++ 相对于其他编程语言的一个独有的性质^[[只有 C++, D, Rust 等屈指可数的几个流行语言支持 RAII]], 使得这门没有动态内存回收机制在某些情况下在资源自动回收方面比其它语言表现得更好.

= 对象及资源复制机制

在 C 中, 当一个函数的返回值定义为结构体时, 调用这个函数获得该结构体实例, 其行为是将这个实例的所有数据复制一份: 从被调用函数的栈区复制到调用者栈区. 譬如以下代码示例

```
struct Person {
    char name[16];               // 栈区
    int age;                     // .-------------------.
};                               // |      main()       |
                                 // |                   |
Person read_person()             // | person q -------. |
{                                // | . name:char[16] |<---.
    Person p;                    // | | age:int       | |  |  函数返回时
    fgets(p.name, 16, stdin);    // | |_______________| |  |  整个 Person 对象会被复制
    scanf("%d", &p.age);         // |                   |  |  包括 16 字节的 char 数组
    return p;                    // |-------------------|  |  和一个 int
}                                // |   read_person()   |  |
                                 // |                   |  |
int main()                       // | person q -------. |  |
{                                // | . name:char[16] |----'
    Person q(read_person());     // | | age:int       | |
    // ...                       // | |_______________| |
    return 0;                    // |                   |
}
```

在 `main` 函数中调用了 `read_person` 后, 很有可能这个对象是从 `read_person` 函数中定义的 `p` 中复制数据而产生 `q`.^[[聪明的编译器会优化规避类似这样的复制, 这种优化称之为 "返回值优化" 或简称为 RVO (**R**eturn **V**alue **O**ptimization), 但在一些复杂的情况下编译器可能不会贸然进行此类优化]] 对于以上定义的纯粹静态对象而言, 问题不大, 除了程序可能会因为大量的复制行为而变慢.

但如果 `Person` 的定义中包含携带资源的对象呢?

```
struct Person {
    std::string name;
    int age;
};

Person read_person()
{
    Person p;
    std::cin >> p.name;
    std::cin >> p.age;
    return p;
}

int main()
{
    // C++ 亦会将被调用函数栈区内的 p 的数据复制到调用者栈区内的 q 中去
    Person q(read_person());
    // ...
    return 0;
}
```

由于 `Person` 对象会包含一个 `std::string` 对象, 如前所述, 作为控制资源 (堆空间中分配的字符串内容) 的对象, 其生命周期结束之后其持有的资源就失效了, 那么在 `read_person` 函数结束的时候, `p.name` 所包含的资源就被归还了, 那么其包含的 `name` 属性内容如何传递给调用者栈区的 `q.name` 中去呢?

首先, 显然不可能等到 `p.name` 析构结束后再从 `p.name` 中复制出 `q.name`, 因为 `p.name` 析构后其持有的资源已经失效, 不可作为复制的来源. 因此这时必然是先复制构造出 `q.name`, 然后再析构掉 `p.name`. 换言之, `p.name` 与 `q.name` 的生命周期会有一点重叠.

然后, 也是更重要的一点, `name` 这个属性是如何复制的? 在解答这个问题时 C++ 引入了有争议性的一个特性: 对象复制构造. 即由用户指定一个资源持有对象的复制行为, 称之为**复制构造函数**, 像 `std::string` 这样的类型, 它的复制构造函数行为被指定为

* 复制目标先分配与复制来源至少一样大的堆空间
* 将构造来源的堆空间上的内容复制到构造目标相应的堆空间上

换言之, 在 `p` 和 `q` 生命周期重叠的这么看似不起眼的一段时间内, 会发生很多事情, 包括新资源分配, 数据复制.

然而这种行为显然是不合理的, 有点像朋友找我借一本书, 我就把这本书带到复印店复印一整本给他, 然后烧了自己手头上这本. 对于字符串这样可以复制的资源来说虽有些蠢但至少还能复制得出副本; 但对于文件句柄, 线程锁, 或者遵守质能守恒的宇宙而言复制是不应发生的. 但是回头看一下这个特性的由来, 又会发现它本是为了兼容 C 在这一情况下的行为, 并且衍生出适用于 C++ 的至少更加安全的资源复制行为.

而不得不说这一兼容的代价是惨重的. 然而实际上, 这些复制行为是 C++ 的日常. 直到 C++11 标准出台.

在上一个标准 C++03 制定之后的 8 年时间里, 修正以上这种无意义的复制行为的补救措施逐步形成文案并被加入了新标准中, 最终形成了 C++11 标准中一个重要的更新: **移动语义** (move semantic). 简而言之, 移动语义允许一份资源从一个对象中**移动**到另一个对象中去, 使得资源可以在不同对象中以较低的运行开销交接, 扩展该资源的有效期.
