在 C++ 中, 若使用一个模板类型的特化作为另一个模板的类型参数, 连续两个模板的结束符号 `>` 会合在一起变为右移算符 `>>`, 如

```!
std::vector<std::pair<int, int>> x;
//                            ^^
std::vector<std::pair<int, std::set<std::string>>> y;
//                                             ^^^ 还可能出现无符号右移算符
```

在 C++03 中这种写法是不允许的, 模板结束处的连续尖括号之间必须加上空格. 而 C++11 标准则允许这样写, 即上述代码可以被支持 C++11 的编译器正确解析. 不过此改动也不是完美的, 这一规则加入后一些原来可以编译通过的代码反而会出错. 如

```!
template <int I>
struct A {};

// 使用右移运算表达式特化接受整型参数的模板
// C++03 中可以编译通过, C++11 中报错
A<3 >> 1> x;
// 两个标准中都认可的写法, 在表达式两边加上括号
A<(3 >> 1)> x;
```

当然也不能说这是设计上的不周, 现实中像上面这样偏偏用到一个右移运算来特化的例子屈指可数, 而嵌套模板的使用则比比皆是. 所以这只是牺牲不常见的用况来方便更常见的写法, 还是很有道理的.
