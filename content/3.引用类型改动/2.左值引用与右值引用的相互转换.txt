由于 C++ 中等号算符是可以重载的, 因此以等号赋值语法来讨论左右值不会有太大意义. 实际上 C++ 的左值概念更多的是基于是否可以取得对象地址, 并在这一地址空间上执行相应的行为来界定的. 并且, 它衍生出了被称之为 **同一性 (identity)** 的概念, 也就是两个对象引用可以根据其地址是否相同而确定是否引用了同一个对象.

而 C 和 C++ 均禁止对临时对象使用取得地址算符 (前置单目 `&` 算符), 无法直接获取地址的表达式当然谈不上同一性, 在 C++11 中这些表达式被称作**纯右值 (pure rvalue)**. 字面常量, 对返回值类型定义为值类型的函数的调用, 各种运算 (包括所有原生对象的算术, 逻辑, 比较运算等), 以及对右值对象的成员, 还包括 lambda 表达式, 都属于纯右值.

同一性的特性还产生了一个 C++ 与 C 行为不一致的地方, 就是 C++ 中对空类型 (没有数据成员或虚函数, 若有父类, 其父类也必须全是空类型) 求 `sizeof` 得到的结果至少为 1, 而 C 中对空结构体求 `sizeof` 得到的是 0. 因此 C++ 可以确保两个对象的地址一定不同. (此外 C++ 中 `struct Empty {} x, y; ptrdiff_t m = &x - &y;` 这样的代码没问题, 但在 C 中会因除零错误而崩溃)

临时对象或字面量都是典型的右值. 而另一种右值则通过非 `const` 限定的左值对象转换而来, 它们被称作**临终值** (eXpiring value 或简写作 **xvalue**). 例如在上一节中提到的方法

```
int six = 6;
test_ref(static_cast<int&&>(six)); // 使用 static_cast 转换得到右值引用
```

当然用户不必每次需要将左值类型转换为临终值都写这么别扭的 `static_cast`, 在标准库中提供了一个函数包装, 它是 `std::move`. 上面的例子中的 `static_cast` 用 `std::move` 替换的等价实现会是这样的

```
int six = 6;
test_ref(std::move(six));
```

调用 `std::move`, 除了让编译器选择右值而不是左值引用的重载, 并没有其它的作用. 不过, 换一个重载在有些情况下大有其作用. 这些用况, 以及为何将左值表达式转换为右值引用的函数称作 `move`, 将在下一章移动语义中重点介绍.

反过来, 右值引用是否可以转化为左值引用呢? 当然可以, 而且不同的是, 甚至都不需要进行一次 `static_cast`. 在 C++11 中规定, 任何带有名字的引用, 这个名字构成的表达式都是一个左值引用, 因为它已经满足同一性的要求, 可以通过名字取得对象地址了 (虽然 C++ 标准没有规定临时对象具体存储在何处).

典型的情况是以函数参数的形式出现. 定义在栈上的局部变量如果是右值引用, 也会受这一规则制约. 例如

```
void test_ref(int& m) { std::cout << "non-const " << m << std::endl; }
void test_ref(int const& m) { std::cout << "const " << m << std::endl; }
void test_ref(int&& m)  { std::cout << "rvalue " << m << std::endl; }

void proxy(int&& g)
{
    test_ref(g);
}

int main()
{
    int&& f = four();
    // 将右值引用传给 test_ref, 匹配的是左值引用重载
    test_ref(f);    // 输出 non-const 4

    // 将右值引用先传给 proxy, proxy 将右值引用形参传给 test_ref
    // 匹配的是左值引用
    proxy(four());  // 输出 non-const 4
    return 0;
}
```

也就是说无论是定义一个具名右值引用还是右值引用作为参数, 用它去调用函数实际匹配的重载都将是左值引用重载, 这是右值应用一个容易误用的特性.

如果需要将右值引用参数还原为一个右值, 则还需要再添加 `std::move` 调用. 如

```
// ...

void proxy(int&& g)
{
    // 将参数 g 传给 std::move, 重新变为临终值
    test_ref(std::move(g));
}

int main()
{
    proxy(four());  // 输出 rvalue 4
    return 0;
}
```

因此在实际项目中处理临时对象时, 应该立即使用之, 而不建议在函数的栈中定义右值引用绑定临时对象, 更不应该将右值引用定义为对象成员.
