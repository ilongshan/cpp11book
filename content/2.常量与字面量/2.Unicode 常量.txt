在 C++11 标准中新引入了 UTF-8 预编码字符串的机制, 可以让编译器在编译时对字符串字面常量进行转码. 如以下代码

```
#include <iostream>

char u[] = u8"汉";

int main()
{
    std::cout << u << std::endl;
    return 0;
}
```

这样在程序运行时将以 UTF-8 的编码输出 "汉" 字, 前提条件之一是编译器能正确处理输入文件的编码, 如 GCC 会从系统上下文获取默认的输入编码方式, 或以 `-finput-charset=` 来指定编码, 此编码应当与输入文件的编码方式一致, 换言之编译器在这时也扮演一个编码器的角色. 另一个前提条件是命令行软件本身能支持 UTF-8 内容的显示, 比如 Linux 的 xterm 能正确显示 UTF-8 编码的内容, 但 Windows 自带的 cmd 则不能正确显示.

由于编译时完成了编码, 得到的结果就是字节序列, 因此定义的 `u` 的类型为 `char[]`.

如果要以宽字符存储字符串字面量, 以前的 `L` 前缀仍然可以用, 但定义出的 `wchar_t` 的宽度仍然是一个编译器确定的值, 这实在是容易引起问题的地方. 所以 C++11 又加入了两个新的固定宽度的字符类型, 以及相应的前缀, 如

```
char16_t c16 = u'汉';   // 小写 u 开头表示以 UTF-16 编码的字符或字符串
char32_t c32 = U'汉';   // 大写 U 开头表示以 UTF-32 编码的字符或字符串
char16_t s16[] = u"汉";
char32_t s32[] = U"汉";
```

请注意, 由于 UTF-8 编码得出的序列不是宽字符, 因此并不存在 `u8'汉'` 字符形式, 只有字符串形式.

然而标准中很尴尬的一点是, 并没有新增对应预定义输出流 (比如 `std::cout` 之于 `char[]` 或 `std::wcout` 之于 `wchar_t[]`), 因此如果在程序中用适于一般字符或宽字符的流来输出它们, 这些字符类型将转换成整数输出, 而字符串将转换为地址输出.

当然, 文本编码并不是简单的几个数据类型换来换去就能解决的, 要按照具体的情况选择合适的方法. 比如 HTTP 通信中向客户端发送内容, 宜用 UTF-8 编码的字节序列; 而本地程序的用户界面最好还是使用专门的国际化工具来转换程序中的字符串.
